---
description: 
globs: src/app/dashboard/components/dashboard.tsx, src/app/dashboard/components/layout/**/*.tsx
alwaysApply: false
---
name: Dashboard Refactoring Guide - Detailed v2
globs: ["src/app/dashboard/components/dashboard.tsx", "src/app/dashboard/components/layout/**/*.tsx", "src/app/dashboard/contexts/**/*.tsx"]
alwaysApply: false
description: "dashboard.tsx 및 관련 컴포넌트들의 복잡성을 줄이고 코드 품질을 향상시키기 위한 상세 리팩토링 규칙입니다. (규칙 1.2, 1.3 추가 상세화)"
---

# Cursor AI 리팩토링 규칙: 대시보드 복잡성 감소 (상세)

## 1. 개요

이 문서는 `dashboard.tsx`를 중심으로 한 애플리케이션 코드의 복잡성을 줄이고, 유지보수성 및 확장성을 향상시키기 위한 리팩토링 규칙을 정의합니다. AI 에이전트는 각 규칙에 따라 작업을 수행해야 합니다.

## 2. 리팩토링 핵심 목표 (참고용)

* **컴포넌트 분리:** 각 컴포넌트의 단일 책임 원칙 준수.
* **상태 관리 개선:** 예측 가능한 상태 변화, 불필요한 리렌더링 감소, 명확한 데이터 흐름. (Context API 적극 활용)
* **로직 분리:** UI 렌더링, 상태 업데이트, 비즈니스 로직 분리.
* **UI 일관성 확보:** 재사용 가능한 UI 컴포넌트 활용 및 일관된 디자인 시스템 적용.
* **타입 안정성 강화:** TypeScript를 통한 컴파일 시점 오류 방지 및 코드 명확성 증대.

## 3. 단계별 리팩토링 실행 규칙

### 1단계: 대시보드 레이아웃 및 핵심 UI 구조 분리

**규칙 1.1: `DashboardLayout.tsx` 컴포넌트 생성 및 이전 (상세 지침)**

* **작업:** `src/app/dashboard/components/layout/DashboardLayout.tsx` 파일을 새로 생성합니다.
* **지침:**
    1.  **기존 레이아웃 구조 이전:**
        * `src/app/dashboard/components/dashboard.tsx` 파일에서 다음 요소들을 `DashboardLayout.tsx`로 이전합니다:
            * 최상위 `div` (flex h-screen 컨테이너).
            * 모바일용 사이드바를 위한 `Sheet` 컴포넌트와 그 자식 요소들.
            * 데스크탑용 정적 사이드바 (`motion.div`로 구현된 부분).
            * 메인 콘텐츠 영역을 감싸는 `div` (flex-1 flex flex-col 구조).
            * `DashboardHeader` (규칙 1.2에서 생성될) 컴포넌트가 위치할 자리와 `Sidebar` (규칙 1.3에서 생성될) 컴포넌트가 위치할 자리를 명시적으로 주석 처리하거나 placeholder로 둡니다.
    2.  **상태 관리 이전 및 정의 (Context API 활용 준비):**
        * `sidebarOpen` (boolean, 모바일 사이드바 열림/닫힘), `setSidebarOpen` 상태 및 관련 로직을 `DashboardLayout.tsx` 내부 `useState`로 정의합니다. (추후 `SidebarContext`로 이전 - 규칙 3.1.1)
        * `collapsed` (boolean, 데스크탑 사이드바 접힘/펼침), `toggleSidebar` 함수 로직을 `DashboardLayout.tsx` 내부 `useState`로 정의합니다. (추후 `SidebarContext`로 이전 - 규칙 3.1.1)
        * `sidebarWidth` 계산 로직 (`collapsed ? "5rem" : "18rem"`)을 `DashboardLayout.tsx` 내부에 유지합니다.
    3.  **애니메이션 로직 이전:**
        * `motion.div`를 사용한 데스크탑 사이드바 너비 애니메이션 (`animate={{ width: sidebarWidth }}`) 로직을 `DashboardLayout.tsx` 내의 해당 사이드바 마크업 부분에 유지합니다.
    4.  **`children` Prop 처리:**
        * `DashboardLayout.tsx`는 `children: React.ReactNode` 타입의 prop을 받아, 메인 콘텐츠 영역 (헤더 아래, 사이드바 오른쪽)에 해당 `children`을 렌더링해야 합니다.
        * 메인 콘텐츠 영역의 `marginLeft` 스타일은 `sidebarWidth`와 `documentPanelOpen`, `projectPanelOpen` (규칙 3.2에서 생성될 `PanelManager`와 관련된 상태)을 고려하여 동적으로 계산되어야 합니다. 초기에는 `DashboardLayout`에서 직접 스타일을 적용하되, CSS 변수 (`var(--sidebar-width)`) 또는 `PanelManager`와의 연동을 고려합니다.
            * **주의:** `documentPanelOpen`, `projectPanelOpen` 상태는 `SidebarContext` 또는 새로운 `PanelContext`에서 관리될 수 있으며, `DashboardLayout`은 이 Context를 구독하여 `marginLeft`를 조정해야 할 수 있습니다. 초기 단계에서는 `sidebarWidth`만 고려하여 `marginLeft`를 설정합니다.
    5.  **`DashboardLayout.tsx` 기본 구조 예시:**
        ```tsx
        // src/app/dashboard/components/layout/DashboardLayout.tsx
        'use client';

        import { useState, ReactNode, useEffect } from 'react';
        import { motion } from 'framer-motion';
        import { Sheet, SheetContent } from '@/components/dashboard_UI/sheet'; // 경로 확인 및 실제 경로로 수정
        // import DashboardHeader from './DashboardHeader'; // 규칙 1.2에서 생성 후 주석 해제
        // import Sidebar from './Sidebar'; // 규칙 1.3에서 생성 후 주석 해제
        // import { useSidebar } from '../../contexts/SidebarContext'; // 규칙 3.1.1 적용 시 주석 해제

        interface DashboardLayoutProps {
          children: ReactNode;
        }

        export default function DashboardLayout({ children }: DashboardLayoutProps) {
          // 규칙 3.1.1 이전: 로컬 상태 사용
          const [sidebarOpen, setSidebarOpen] = useState(false);
          const [collapsed, setCollapsed] = useState(false);
          
          // 규칙 3.1.1 적용 후: Context 사용 (아래 코드는 예시이며, 실제로는 useSidebar() 훅을 통해 가져옴)
          // const { 
          //   sidebarOpen, setSidebarOpen, 
          //   collapsed, setCollapsed, // toggleSidebarCollapse 대신 setCollapsed 직접 사용 또는 toggleSidebarCollapse context에 추가
          //   documentPanelOpen, projectPanelOpen // 규칙 3.2 PanelManager 연동 시 필요
          // } = useSidebar ? useSidebar() : { sidebarOpen: false, setSidebarOpen: () => {}, collapsed: false, setCollapsed: () => {}, documentPanelOpen: false, projectPanelOpen: false };


          const toggleSidebarCollapse = () => setCollapsed(!collapsed); // Context 이전 시 Context 함수 사용
          const sidebarWidth = collapsed ? "5rem" : "18rem";
          // const documentPanelWidth = "18rem"; // 예시, 실제 PanelManager에서 관리될 수 있음
          // const projectPanelWidth = "18rem"; // 예시

          // 메인 콘텐츠 marginLeft 계산 (CSS 변수 사용 권장)
          // useEffect(() => {
          //   let currentMarginLeft = sidebarWidth;
          //   if (documentPanelOpen) { // 규칙 3.2 PanelManager 연동 시
          //     currentMarginLeft = `calc(${sidebarWidth} + ${documentPanelWidth})`;
          //   } else if (projectPanelOpen) { // 규칙 3.2 PanelManager 연동 시
          //     currentMarginLeft = `calc(${sidebarWidth} + ${projectPanelWidth})`;
          //   }
          //   document.documentElement.style.setProperty('--main-content-margin-left', currentMarginLeft);
          // }, [sidebarWidth, documentPanelOpen, projectPanelOpen]);


          return (
            <div className="flex h-screen bg-gray-100 dark:bg-gray-900">
              {/* Mobile Sidebar (Sheet) */}
              <Sheet open={sidebarOpen} onOpenChange={setSidebarOpen}>
                <SheetContent side="left" className="p-0 w-[280px] bg-white dark:bg-gray-800">
                  {/* TODO: 규칙 1.3에서 생성될 Sidebar 컴포넌트로 대체 */}
                  {/* <Sidebar isMobile onNavItemClick={() => setSidebarOpen(false)} /> */}
                  <div className="p-4">모바일 사이드바 컨텐츠 (Sidebar 컴포넌트로 대체 예정)</div>
                </SheetContent>
              </Sheet>

              {/* Desktop Sidebar */}
              <motion.div
                className="hidden lg:flex lg:flex-col lg:fixed lg:inset-y-0 lg:z-40 border-r border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800"
                animate={{ width: sidebarWidth }}
                transition={{ duration: 0.3, ease: 'easeInOut' }}
                // CSS 변수를 통해 사이드바 너비를 PanelManager 등 다른 컴포넌트에서 참조할 수 있도록 설정
                style={{ '--sidebar-width': sidebarWidth } as React.CSSProperties}
              >
                {/* TODO: 규칙 1.3에서 생성될 Sidebar 컴포넌트로 대체 */}
                {/* <Sidebar collapsed={collapsed} onToggleCollapse={toggleSidebarCollapse} /> */}
                <div className="p-4 flex-1">데스크탑 사이드바 (collapsed: {String(collapsed)}) (Sidebar 컴포넌트로 대체 예정)</div>
                <button onClick={toggleSidebarCollapse} className="p-2 m-2 border rounded hover:bg-gray-100 dark:hover:bg-gray-700">
                  {collapsed ? "펼치기" : "접기"}
                </button>
              </motion.div>

              {/* Main Content Area */}
              <div
                className="flex-1 flex flex-col overflow-hidden"
                style={{
                  // CSS 변수를 사용하거나, PanelManager와 연동하여 marginLeft 동적 계산
                  marginLeft: `var(--sidebar-width, ${sidebarWidth})`, 
                  transition: 'margin-left 0.3s ease-in-out',
                }}
              >
                {/* TODO: 규칙 1.2에서 생성될 DashboardHeader 컴포넌트 */}
                {/* <DashboardHeader onMobileMenuClick={() => setSidebarOpen(true)} /> */}
                <div className="h-16 bg-white dark:bg-gray-800 border-b dark:border-gray-700 flex items-center justify-between px-4">
                  <span>헤더 영역 (DashboardHeader 컴포넌트로 대체 예정)</span>
                  <button onClick={() => setSidebarOpen(true)} className="lg:hidden p-2 text-gray-500">모바일 메뉴</button>
                </div>
                
                <main className="flex-1 overflow-y-auto p-4 md:p-6 lg:p-8">
                  {children}
                </main>
              </div>
            </div>
          );
        }
        ```
    6.  **`dashboard.tsx` 수정:**
        * `DashboardLayout`을 import 하고, 기존 레이아웃 코드를 `DashboardLayout`으로 감싸도록 수정합니다.
        * `DashboardLayout`으로 이전된 상태와 로직은 `dashboard.tsx`에서 제거합니다.
        * **주의:** `DashboardLayout`이 Context Provider (`SidebarProvider` 등)를 포함하도록 수정될 수 있습니다 (규칙 3.1.1). 초기에는 `dashboard.tsx`에서 `DashboardLayout`을 직접 사용합니다.
* **참고 파일:** `src/app/dashboard/components/dashboard.tsx`

---

**규칙 1.2: `DashboardHeader.tsx` 컴포넌트 생성 및 이전 (상세 지침)**

* **작업:** `src/app/dashboard/components/layout/DashboardHeader.tsx` 파일을 새로 생성합니다.
* **지침 (상세):**
    1.  **기존 헤더 구조 식별 및 이전:**
        * `src/app/dashboard/components/dashboard.tsx` (또는 규칙 1.1에 따라 `DashboardLayout.tsx`로 이전된 임시 헤더 영역)에서 현재 헤더 UI를 구성하는 JSX 요소들을 `DashboardHeader.tsx`로 이전합니다.
        * 이전 대상 요소:
            * 모바일용 햄버거 메뉴 버튼 (`Bars3Icon`).
            * 검색 폼 (`MagnifyingGlassIcon` 및 `input` 요소).
            * 알림 아이콘 버튼 (`NotificationBell.tsx` 컴포넌트 사용).
            * 사용자 프로필 드롭다운 (`UserProfileDropdown.tsx` 컴포넌트 사용).
            * 관련 스타일링 클래스 (Tailwind CSS).
    2.  **Props 정의 및 인터페이스:**
        * `DashboardHeader.tsx`는 모바일 사이드바를 열기 위한 콜백 함수를 prop으로 받아야 합니다.
            ```typescript
            interface DashboardHeaderProps {
              onMobileMenuClick: () => void;
            }
            ```
    3.  **컴포넌트 구현:**
        * `'use client';` 지시어를 파일 최상단에 추가합니다.
        * 필요한 아이콘 (`Bars3Icon`, `MagnifyingGlassIcon`) 및 UI 부품 컴포넌트 (`UserProfileDropdown`, `NotificationBell`)를 import 합니다.
        * `onMobileMenuClick` prop을 햄버거 메뉴 버튼의 `onClick` 이벤트에 연결합니다.
        * 검색 기능은 초기에는 UI만 구현하고, 실제 검색 로직은 `SearchContext` (규칙 3.3) 연동 시 구현합니다.
    4.  **`DashboardHeader.tsx` 기본 구조 예시:**
        ```tsx
        // src/app/dashboard/components/layout/DashboardHeader.tsx
        'use client';

        import { Bars3Icon, MagnifyingGlassIcon } from '@heroicons/react/24/outline';
        import UserProfileDropdown from '../ui_parts/UserProfileDropdown'; // 실제 경로 확인
        import NotificationBell from '../ui_parts/NotificationBell';   // 실제 경로 확인
        // import { useSearch } from '../../contexts/SearchContext'; // 규칙 3.3 적용 시

        interface DashboardHeaderProps {
          onMobileMenuClick: () => void;
        }

        export default function DashboardHeader({ onMobileMenuClick }: DashboardHeaderProps) {
          // const { searchQuery, setSearchQuery } = useSearch ? useSearch() : { searchQuery: '', setSearchQuery: () => {} }; // 규칙 3.3 적용 시

          return (
            <div className="sticky top-0 z-30 flex h-16 shrink-0 items-center gap-x-4 border-b border-gray-200 bg-white px-4 shadow-sm sm:gap-x-6 sm:px-6 lg:px-8 dark:bg-gray-800 dark:border-gray-700">
              {/* Mobile menu button */}
              <button
                type="button"
                onClick={onMobileMenuClick}
                className="-m-2.5 p-2.5 text-gray-700 lg:hidden dark:text-gray-200"
              >
                <span className="sr-only">Open sidebar</span>
                <Bars3Icon aria-hidden="true" className="h-6 w-6" />
              </button>

              {/* Separator */}
              <div className="h-6 w-px bg-gray-200 lg:hidden dark:bg-gray-700" aria-hidden="true" />

              <div className="flex flex-1 gap-x-4 self-stretch lg:gap-x-6">
                {/* Search form */}
                <form className="relative flex flex-1" action="#" method="GET">
                  <label htmlFor="search-field" className="sr-only">
                    Search
                  </label>
                  <MagnifyingGlassIcon
                    className="pointer-events-none absolute inset-y-0 left-0 h-full w-5 text-gray-400 dark:text-gray-500"
                    aria-hidden="true"
                  />
                  <input
                    id="search-field"
                    className="block h-full w-full border-0 py-0 pl-8 pr-0 text-gray-900 placeholder:text-gray-400 focus:ring-0 sm:text-sm dark:bg-gray-800 dark:text-gray-100 dark:placeholder:text-gray-500"
                    placeholder="Search..."
                    type="search"
                    name="search"
                    // value={searchQuery} // 규칙 3.3 적용 시
                    // onChange={(e) => setSearchQuery(e.target.value)} // 규칙 3.3 적용 시
                  />
                </form>

                {/* Right side icons */}
                <div className="flex items-center gap-x-4 lg:gap-x-6">
                  <NotificationBell />

                  {/* Separator */}
                  <div className="hidden lg:block lg:h-6 lg:w-px lg:bg-gray-200 dark:bg-gray-700" aria-hidden="true" />

                  <UserProfileDropdown />
                </div>
              </div>
            </div>
          );
        }
        ```
    5.  **`DashboardLayout.tsx` 수정:**
        * `DashboardHeader` 컴포넌트를 import 합니다.
            ```tsx
            import DashboardHeader from './DashboardHeader';
            ```
        * `DashboardLayout.tsx`의 임시 헤더 영역 (또는 `dashboard.tsx`에서 헤더가 있던 자리)을 다음과 같이 교체합니다:
            ```tsx
            <DashboardHeader onMobileMenuClick={() => setSidebarOpen(true)} /> 
            {/* setSidebarOpen은 DashboardLayout의 로컬 상태 또는 SidebarContext에서 가져온 함수 */}
            ```
        * 헤더와 관련된 상태 및 로직 (예: 모바일 메뉴 버튼 클릭 처리)이 `DashboardHeader` 또는 그 부모(주로 `DashboardLayout` 또는 Context)로 적절히 이전되었는지 확인하고, 중복 코드를 제거합니다.
* **참고 파일:** `src/app/dashboard/components/dashboard.tsx`, `src/app/dashboard/components/layout/DashboardLayout.tsx`, `src/app/dashboard/components/ui_parts/UserProfileDropdown.tsx`, `src/app/dashboard/components/ui_parts/NotificationBell.tsx`

---

**규칙 1.3: `Sidebar.tsx` 컴포넌트 생성 및 이전 (상세 지침)**

* **작업:** `src/app/dashboard/components/layout/Sidebar.tsx` 파일을 새로 생성합니다.
* **지침 (상세):**
    1.  **기존 사이드바 구조 식별 및 이전:**
        * `DashboardLayout.tsx` (규칙 1.1에 따라 이전된)에서 데스크톱용 `motion.div` 사이드바와 모바일용 `SheetContent` 내부의 사이드바 컨텐츠를 `Sidebar.tsx`로 이전합니다.
        * 이전 대상 요소:
            * 네비게이션 링크 목록 (`navigation` 배열을 기반으로 렌더링되는 `ul > li > Link` 구조).
            * 각 링크의 아이콘 및 텍스트.
            * 데스크톱 사이드바의 접기/펼치기 버튼 (만약 `DashboardLayout`에 임시로 구현했다면).
            * 설정(Settings) 링크.
            * 관련 스타일링 클래스 (Tailwind CSS).
    2.  **Props 정의 및 인터페이스:**
        * `Sidebar.tsx`는 다양한 상황(모바일/데스크톱, 접힘/펼침)에 대응할 수 있도록 props를 정의합니다.
            ```typescript
            // src/app/dashboard/contexts/SidebarContext.tsx 또는 별도 types 파일에 정의된 NavigationItem 사용
            import type { NavigationItem } from '../../contexts/SidebarContext'; // 실제 경로 확인

            interface SidebarProps {
              isMobile?: boolean; // 모바일 뷰 여부 (Sheet 내부에서 사용될 때 true)
              // collapsed, onToggleCollapse, activeNavItem, onNavItemClick 등은 Context에서 가져오므로 직접적인 prop으로는 불필요할 수 있음
              // 만약 Context를 사용하지 않는다면 아래 props들이 필요:
              // collapsed?: boolean; // 데스크톱 사이드바 접힘 상태
              // onToggleCollapse?: () => void; // 데스크톱 사이드바 접힘/펼침 토글 함수
              // activeNavItem?: string; // 현재 활성화된 네비게이션 아이템 이름
              // onNavItemClick?: (item: NavigationItem) => void; // 네비게이션 아이템 클릭 핸들러
              // onSettingsClick?: () => void; // 설정 아이템 클릭 핸들러
            }
            ```
    3.  **`SidebarContext` 활용:**
        * `Sidebar.tsx`는 `useSidebar` 훅을 사용하여 `SidebarContext`의 상태와 함수들을 가져와 사용합니다.
            * `collapsed`: 데스크톱 사이드바의 접힘 상태.
            * `toggleSidebarCollapse`: 데스크톱 사이드바 접힘/펼침 토글 함수.
            * `activeNavItem`: 현재 활성화된 네비게이션 아이템 이름.
            * `navigationItems`: 렌더링할 네비게이션 아이템 목록.
            * `handleNavItemClick`: 네비게이션 아이템 클릭 시 호출될 함수 (Context 내부에서 `activeNavItem` 변경 및 패널 상태 관리).
            * `setSidebarOpen`: 모바일 사이드바를 닫기 위해 사용 (네비게이션 아이템 클릭 시).
    4.  **컴포넌트 구현:**
        * `'use client';` 지시어를 파일 최상단에 추가합니다.
        * `framer-motion`의 `motion`, `AnimatePresence`를 import 하여 접힘/펼침 애니메이션을 구현합니다.
        * `Link` 컴포넌트 (Next.js)를 사용하여 네비게이션 링크를 구현합니다.
        * `navigationItems` 배열을 순회하며 각 네비게이션 링크를 렌더링합니다.
        * `activeNavItem` 상태를 기반으로 현재 활성화된 링크에 스타일을 적용합니다.
        * `collapsed` 상태에 따라 아이콘만 표시하거나 아이콘과 텍스트를 함께 표시하도록 조건부 렌더링을 적용합니다. (애니메이션 포함)
        * 모바일(`isMobile={true}`)일 경우와 데스크톱일 경우 UI/UX 차이를 고려합니다. (예: 모바일에서는 접기 버튼 불필요)
        * 설정(Settings) 링크는 네비게이션 목록 하단에 고정적으로 표시될 수 있으며, 클릭 시 `handleNavItemClick`을 통해 `activeNavItem`을 'Settings'로 변경합니다.
    5.  **`Sidebar.tsx` 기본 구조 예시:**
        ```tsx
        // src/app/dashboard/components/layout/Sidebar.tsx
        'use client';

        import Link from 'next/link';
        import { motion, AnimatePresence } from 'framer-motion';
        import { Settings, PanelLeftClose, PanelLeftOpen } from 'lucide-react'; // 아이콘 추가
        import { useSidebar } from '../../contexts/SidebarContext'; // 실제 경로 확인
        import type { NavigationItem } from '../../contexts/SidebarContext'; // 타입 import

        function classNames(...classes: string[]) {
          return classes.filter(Boolean).join(' ');
        }

        interface SidebarProps {
          isMobile?: boolean;
        }

        export default function Sidebar({ isMobile = false }: SidebarProps) {
          const {
            collapsed,
            toggleSidebarCollapse,
            activeNavItem,
            navigationItems,
            handleNavItemClick, // Context에서 제공하는 통합 핸들러 사용
            setSidebarOpen,     // 모바일 사이드바 닫기용
            documentPanelOpen,  // 'Documents' 아이템 활성화 상태 판단용
            projectPanelOpen    // 'Projects' 아이템 활성화 상태 판단용
          } = useSidebar();

          const internalHandleLinkClick = (item: NavigationItem) => {
            handleNavItemClick(item); // Context의 핸들러 호출
            if (isMobile) {
              setSidebarOpen(false); // 모바일에서는 링크 클릭 시 사이드바 닫기
            }
          };
          
          const internalHandleSettingsClick = () => {
            // Settings 아이템 객체를 직접 만들거나, navigationItems에 포함된 것을 찾아 사용
            const settingsItem = navigationItems.find(nav => nav.name === 'Settings') || 
                               { name: 'Settings', href: '#', icon: Settings, current: activeNavItem === 'Settings' };
            handleNavItemClick(settingsItem);
            if (isMobile) {
              setSidebarOpen(false);
            }
          };


          return (
            <div className={classNames(
              "flex grow flex-col gap-y-5 overflow-y-auto bg-white px-2 pb-4 pt-4 dark:bg-gray-800",
              isMobile ? "px-6" : "px-2" // 모바일일 때 패딩 조정
            )}>
              {/* 데스크톱용 접기/펼치기 버튼 */}
              {!isMobile && (
                <div className="flex items-center justify-end px-1 mb-2">
                  <button
                    onClick={toggleSidebarCollapse}
                    className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                    aria-label={collapsed ? "Expand sidebar" : "Collapse sidebar"}
                  >
                    {collapsed ? (
                      <PanelRightOpen className="h-5 w-5 text-indigo-600 dark:text-indigo-400" />
                    ) : (
                      <PanelLeftClose className="h-5 w-5 text-indigo-600 dark:text-indigo-400" />
                    )}
                  </button>
                </div>
              )}

              {/* 모바일용 헤더 (선택 사항, 필요시 SheetContent 내부에서 직접 처리 가능) */}
              {isMobile && (
                <div className="flex h-8 items-center justify-between px-4">
                  <span className="text-lg font-semibold text-gray-800 dark:text-white">Menu</span>
                </div>
              )}

              <nav className="flex flex-1 flex-col">
                <ul role="list" className="flex flex-1 flex-col gap-y-7">
                  <li>
                    <ul role="list" className="-mx-2 space-y-1">
                      {navigationItems.map((item) => (
                        <li key={item.name}>
                          <Link
                            href={item.href}
                            onClick={() => internalHandleLinkClick(item)}
                            className={classNames(
                              // activeNavItem 비교 시 패널 열림 상태도 고려
                              (activeNavItem === item.name || (item.name === 'Documents' && documentPanelOpen) || (item.name === 'Projects' && projectPanelOpen))
                                ? 'bg-gray-100 text-indigo-600 dark:bg-gray-700 dark:text-indigo-300'
                                : 'text-gray-700 hover:bg-gray-50 hover:text-indigo-600 dark:text-gray-300 dark:hover:bg-gray-700 dark:hover:text-indigo-400',
                              'group flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6',
                              collapsed && !isMobile ? 'justify-center' : '' // 접혔을 때 아이콘 중앙 정렬
                            )}
                          >
                            <item.icon
                              className={classNames(
                                (activeNavItem === item.name || (item.name === 'Documents' && documentPanelOpen) || (item.name === 'Projects' && projectPanelOpen))
                                  ? 'text-indigo-600 dark:text-indigo-300'
                                  : 'text-gray-400 group-hover:text-indigo-600 dark:text-gray-500 dark:group-hover:text-indigo-400',
                                'h-6 w-6 shrink-0'
                              )}
                              aria-hidden="true"
                            />
                            <AnimatePresence>
                              {(!collapsed || isMobile) && (
                                <motion.span
                                  initial={{ opacity: 0, width: 0 }}
                                  animate={{ opacity: 1, width: 'auto' }}
                                  exit={{ opacity: 0, width: 0 }}
                                  transition={{ duration: 0.2, ease: 'easeInOut' }}
                                  className="overflow-hidden whitespace-nowrap"
                                >
                                  {item.name}
                                </motion.span>
                              )}
                            </AnimatePresence>
                          </Link>
                        </li>
                      ))}
                    </ul>
                  </li>
                  <li className="mt-auto">
                    <Link
                      href="#" // 실제 Settings 페이지 경로로 변경 가능
                      onClick={internalHandleSettingsClick}
                      className={classNames(
                        activeNavItem === 'Settings'
                          ? 'bg-gray-100 text-indigo-600 dark:bg-gray-700 dark:text-indigo-300'
                          : 'text-gray-700 hover:bg-gray-50 hover:text-indigo-600 dark:text-gray-300 dark:hover:bg-gray-700 dark:hover:text-indigo-400',
                        'group -mx-2 flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6',
                        collapsed && !isMobile ? 'justify-center' : ''
                      )}
                    >
                      <Settings
                        className={classNames(
                          activeNavItem === 'Settings'
                            ? 'text-indigo-600 dark:text-indigo-300'
                            : 'text-gray-400 group-hover:text-indigo-600 dark:text-gray-500 dark:group-hover:text-indigo-400',
                          'h-6 w-6 shrink-0'
                        )}
                        aria-hidden="true"
                      />
                      <AnimatePresence>
                        {(!collapsed || isMobile) && (
                           <motion.span
                             initial={{ opacity: 0, width: 0 }}
                             animate={{ opacity: 1, width: 'auto' }}
                             exit={{ opacity: 0, width: 0 }}
                             transition={{ duration: 0.2, ease: 'easeInOut' }}
                             className="overflow-hidden whitespace-nowrap"
                           >
                            Settings
                           </motion.span>
                        )}
                      </AnimatePresence>
                    </Link>
                  </li>
                </ul>
              </nav>
            </div>
          );
        }
        ```
        * **`PanelRightOpen` 아이콘:** `lucide-react`에 `PanelRightOpen`이 없을 수 있습니다. 이 경우 `PanelLeftOpen`을 사용하거나, `PanelLeft` 아이콘을 회전시켜 사용하거나, 다른 적절한 아이콘(예: `ChevronsRight`)으로 대체해야 합니다. 예시에서는 `PanelLeftOpen`으로 임시 사용했습니다.
    6.  **`DashboardLayout.tsx` 수정:**
        * 생성된 `Sidebar` 컴포넌트를 import 합니다.
            ```tsx
            import Sidebar from './Sidebar';
            ```
        * 모바일용 `SheetContent` 내부의 임시 사이드바 컨텐츠를 다음과 같이 교체합니다:
            ```tsx
            <SheetContent side="left" className="p-0 w-[280px] bg-white dark:bg-gray-800">
              <Sidebar isMobile />
              {/* onNavItemClick과 같은 prop은 Sidebar 내부에서 Context를 통해 처리되므로 제거 가능 */}
            </SheetContent>
            ```
        * 데스크톱용 `motion.div` 내부의 임시 사이드바 컨텐츠를 다음과 같이 교체합니다:
            ```tsx
            <motion.div ... >
              <Sidebar />
              {/* collapsed, onToggleCollapse 등의 prop은 Sidebar 내부에서 Context를 통해 처리되므로 제거 가능 */}
            </motion.div>
            ```
        * `DashboardLayout.tsx`에서 사이드바와 직접적으로 관련된 상태(`collapsed`, `activeNavItem` 등) 및 함수(`toggleSidebarCollapse`, `handleNavItemClick` 등)는 `SidebarContext`로 이전되었으므로 제거합니다. `sidebarWidth` 계산 로직은 `DashboardLayout`에 유지하거나 `SidebarContext`로 옮길 수 있습니다 (UI와 밀접하므로 `DashboardLayout` 유지가 나을 수 있음).
* **참고 파일:** `src/app/dashboard/components/layout/DashboardLayout.tsx`, `src/app/dashboard/contexts/SidebarContext.tsx`

---

**(이하 규칙들은 위와 같은 방식으로 각 "지침" 항목을 구체화합니다. 특히 Context API 도입 (규칙 3.x) 및 PanelManager (규칙 3.2) 구현 시에는 상태와 props 흐름이 크게 변경되므로 더욱 상세한 가이드가 필요합니다.)**

**규칙 4.1 (RichText 편집기 툴바 UI 미니멀리즘 적용)에 대한 구체화된 지침 (기존 제공 내용 유지 및 보강):**

* **지침 (상세):**
    1.  **아이콘으로 대체:** `src/app/dashboard/components/rich-text-editor.tsx` (또는 리팩토링된 `EditorToolbar.tsx`) 파일의 툴바 `Button` 컴포넌트들에서 텍스트 레이블을 제거하고, `lucide-react`에서 제공하는 적절한 아이콘(예: `Bold`, `Italic`, `Heading1` 등)으로 대체합니다. 모든 아이콘의 크기는 `className="w-4 h-4"` (또는 `size={16}`)로 통일합니다.
        * **주의:** `lucide-react` 아이콘 목록을 확인하여 정확한 아이콘 이름을 사용해야 합니다.
    2.  **버튼 스타일 수정:**
        * `src/app/dashboard/styles/dashboard.css` 파일에서 `.editor-toolbar button` (또는 해당 Tailwind 클래스 그룹)의 스타일을 수정하거나, Tailwind CSS 유틸리티 클래스를 직접 버튼에 적용합니다.
        * `padding`을 `p-1.5` 또는 `p-1` 정도로 줄입니다. (예: `className="p-1.5"`)
        * 버튼의 `width`와 `height`를 `w-8 h-8` (또는 `size-8`) 정도로 조정하여 더 컴팩트하게 만듭니다. (예: `className="w-8 h-8"`)
        * 활성화된 버튼(Tiptap의 `editor.isActive(...)` 활용)에는 `bg-slate-200 dark:bg-slate-700`과 같은 배경색을 적용하여 시각적으로 구분합니다. (예: `className={editor.isActive('bold') ? 'bg-slate-200 dark:bg-slate-700' : ''}`)
    3.  **툴팁 추가:** 각 아이콘 버튼에 마우스 호버 시 기능 설명을 간략하게 보여주는 툴팁을 추가합니다.
        * 간단하게는 `title` HTML 속성을 사용할 수 있습니다. (예: `<Button title="굵게">...`)
        * 더 나은 사용자 경험을 위해 `src/components/dashboard_UI/popover.tsx`의 `Popover`, `PopoverTrigger`, `PopoverContent`를 활용하여 커스텀 툴팁을 구현하는 것을 고려합니다.
            ```tsx
            // Popover를 사용한 툴팁 예시
            import { Popover, PopoverTrigger, PopoverContent } from '@/components/dashboard_UI/popover'; // 경로 확인
            // ...
            <Popover>
              <PopoverTrigger asChild>
                <Button variant={editor.isActive('bold') ? 'secondary' : 'ghost'} size="icon" className="p-1.5 w-8 h-8">
                  <Bold className="w-4 h-4" />
                </Button>
              </PopoverTrigger>
              <PopoverContent className="text-xs p-2 shadow-md rounded-md bg-gray-900 text-white dark:bg-gray-50 dark:text-gray-900">
                굵게 (Ctrl+B)
              </PopoverContent>
            </Popover>
            ```
    4.  **드롭다운 메뉴로 그룹화:**
        * 헤딩 버튼들(H1, H2, H3)을 `src/components/dashboard_UI/dropdown-menu.tsx`의 `DropdownMenu`를 사용하여 "헤딩 스타일" 드롭다운 메뉴로 통합합니다. 드롭다운 트리거는 `Heading` 아이콘 (또는 `Heading1` 등 대표 아이콘)을 사용합니다.
            ```tsx
            // DropdownMenu를 사용한 헤딩 그룹화 예시
            import { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem } from '@/components/dashboard_UI/dropdown-menu'; // 경로 확인
            import { Heading } from 'lucide-react'; // 또는 Heading1 등
            // ...
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" className="p-1.5 w-8 h-8" title="헤딩 스타일">
                  <Heading className="w-4 h-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent>
                <DropdownMenuItem onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}>
                  <Heading1 className="w-4 h-4 mr-2" /> 제목 1
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}>
                  <Heading2 className="w-4 h-4 mr-2" /> 제목 2
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()}>
                  <Heading3 className="w-4 h-4 mr-2" /> 제목 3
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
            ```
        * 텍스트 정렬 버튼들(AlignLeft, AlignCenter, AlignRight, AlignJustify)도 "텍스트 정렬" 드롭다운 메뉴로 통합하는 것을 고려합니다. 드롭다운 트리거는 `AlignLeft` (또는 유사한 대표 아이콘)를 사용합니다.
    5.  **참고 코드 (툴바 버튼 예시 - Popover 툴팁 적용):**
        ```tsx
        // RichTextEditor.tsx 또는 EditorToolbar.tsx 내 툴바 버튼 예시
        import { Popover, PopoverTrigger, PopoverContent } from '@/components/dashboard_UI/popover'; // 경로 확인
        import { Button } from '@/components/dashboard_UI/button'; // Shadcn/UI 버튼 사용 시
        import { Bold } from 'lucide-react';

        // ... editor 인스턴스가 사용 가능하다고 가정 ...

        <Popover>
          <PopoverTrigger asChild>
            <Button
              variant={editor.isActive('bold') ? 'secondary' : 'ghost'}
              size="icon" // Shadcn/UI 버튼의 아이콘 전용 사이즈 (또는 직접 w-8 h-8 적용)
              onClick={() => editor.chain().focus().toggleBold().run()}
              className="p-1.5 w-8 h-8" // 패딩과 크기 조정 (size="icon"과 중복될 수 있으므로 확인 필요)
            >
              <Bold className="w-4 h-4" />
              <span className="sr-only">굵게</span>
            </Button>
          </PopoverTrigger>
          <PopoverContent className="text-xs p-1.5 shadow-md rounded-md bg-gray-900 text-white dark:bg-gray-50 dark:text-gray-900 w-auto">
            굵게 (Ctrl+B)
          </PopoverContent>
        </Popover>
        ```
* **참고 파일:** `src/app/dashboard/components/rich-text-editor.tsx` (또는 리팩토링된 `EditorToolbar.tsx`), `src/components/dashboard_UI/button.tsx`, `src/components/dashboard_UI/popover.tsx`, `src/components/dashboard_UI/dropdown-menu.tsx`, `src/app/dashboard/styles/dashboard.css` (필요시)

